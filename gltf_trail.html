<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Demo for HW Design Labs</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>

        <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
        <script type="importmap">
        {
            "imports": {
            "three": "https://unpkg.com/three@0.145.0/build/three.module.js"
            }
        }
        </script>

		<script type="module">
            import * as THREE from 'three';
            import { OrbitControls } from 'https://unpkg.com/three@0.145.0/examples/jsm/controls/OrbitControls.js';
            import { GLTFLoader } from 'https://unpkg.com/three@0.145.0/examples/jsm/loaders/GLTFLoader.js';

            var sphere_array_red = [];
            var sphere_array_green = [];
            var sphere_array_blue = [];
            var num_spheres_red_history = 40;
            var num_spheres_green_history = 40;
            var num_spheres_blue_history = 40;
            var sphere_radius_min = 0.1;
            var sphere_radius_max = 0.6;
            var sphere_red_start_color = 0xffff00;
            var sphere_green_start_color = 0x00ffff;
            var sphere_blue_start_color = 0xff00ff;
            var sphere_red_end_color = 0xff0000;
            var sphere_green_end_color = 0x00ff00;
            var sphere_blue_end_color = 0x0000ff;
            var input_scale_factor_x = 100;
            var input_scale_factor_y = 100;
            var input_scale_factor_z = 100;
            var offset_x = -10;
            var offset_y = 0;
            var offset_z = -10;
            var sphere_size_scale_factor = 0.98;

            var create_sphere = function(x, y, z, radius, fill_color)
            {
                const sphere_geometry = new THREE.SphereGeometry( radius, 32, 16 );
                const sphere_material = new THREE.MeshBasicMaterial( { color: fill_color } );
                const sphere = new THREE.Mesh( sphere_geometry, sphere_material );
                sphere.position.x = x;
                sphere.position.y = y;
                sphere.position.z = z;
                return sphere;
            }

            var change_sphere_position = function(scene, sphere_array, num_spheres, x, y, z, radius, start_color, end_color)
            {
                /* Remove all the existing objects */
                for (let i = 0; i < sphere_array.length; i++)
                {
                    scene.remove(sphere_array[i]);
                }
                
                var new_sphere = create_sphere(x, y, z, radius, end_color);

                sphere_array.push(new_sphere);
                
                var num_excess_spheres = sphere_array.length - num_spheres;
                if (num_excess_spheres > 0)
                    for (let i = 0; i < num_excess_spheres; i++)
                        sphere_array.shift();
                
                for (let i = 0; i < sphere_array.length; i++)
                {
                    sphere_array[i].scale.multiplyScalar(sphere_size_scale_factor);
                    sphere_array[i].scale.clampScalar(sphere_radius_min, sphere_radius_max);
                    var alphaRatio = (i / sphere_array.length);
                    sphere_array[i].material.color.copy(new THREE.Color(start_color)).lerp(new THREE.Color(end_color), alphaRatio);
                    scene.add(sphere_array[i]);
                }
            }

            const renderer = new THREE.WebGLRenderer({alpha:true});
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            const camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, sphere_radius_min * 0.01, 50 );

            const controls = new OrbitControls( camera, renderer.domElement );
            camera.position.set( 10, 10, 10 );
            camera.lookAt( 0, 0, 0 );
            controls.update();

            const scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x999999 );

            const light = new THREE.HemisphereLight( 0xffffff, 0x000000, 1 );
            light.position.x = -0.757;
            light.position.z = 7.873;
            light.position.y = -6.582;
            scene.add(light);

            const loader = new GLTFLoader().setPath('models/gltf/');
            loader.load('scene.gltf', function(gltf) {
                scene.add(gltf.scene);
                renderer.render( scene, camera );
            });

            renderer.render( scene, camera );

            const socket = new WebSocket('ws://localhost:8000');
            var websockConnected = false;
            function animate() 
            {
	            requestAnimationFrame( animate );
                controls.update();
                if (websockConnected == true) 
                    socket.send("Hello");
                //set_sphere_position(sphere_red, sphere_red.position.x + 1, sphere_red.position.y, sphere_red.position.z);
	            renderer.render( scene, camera );
            }

            socket.addEventListener('open', function (event) {
                websockConnected = true;
            });

            socket.addEventListener('message', function (event) {
                var rs = JSON.parse(event.data)
                var sphere_data = JSON.parse(rs['received_string']);
                console.log(sphere_data);
                if (sphere_data.id == "red")
                {
                    change_sphere_position(scene, sphere_array_red, num_spheres_red_history, sphere_data.x/input_scale_factor_x + offset_x, sphere_data.y/input_scale_factor_y + offset_y, -1 * sphere_data.z/input_scale_factor_z + offset_z, sphere_radius_max, sphere_red_start_color, sphere_red_end_color);
                }
                if (sphere_data.id == "green")
                {
                    change_sphere_position(scene, sphere_array_green, num_spheres_green_history, sphere_data.x/input_scale_factor_x + offset_x, sphere_data.y/input_scale_factor_y + offset_y, -1 * sphere_data.z/input_scale_factor_z + offset_z, sphere_radius_max, sphere_green_start_color, sphere_green_end_color);
                }
                if (sphere_data.id == "blue")
                {
                    change_sphere_position(scene, sphere_array_blue, num_spheres_blue_history, sphere_data.x/input_scale_factor_x + offset_x, sphere_data.y/input_scale_factor_y + offset_y, -1 * sphere_data.z/input_scale_factor_z + offset_z, sphere_radius_max, sphere_blue_start_color, sphere_blue_end_color);
                }
            });

            animate();            
        </script>
	</body>
</html>